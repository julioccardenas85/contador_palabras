/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Window;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PushbackInputStream;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import static java.util.Collections.reverseOrder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.JFileChooser;

/**
 *
 * @author julio
 */
public class Window extends javax.swing.JFrame {

    /**
     * Creates new form java
     */
    public Window() {
        initComponents();
        barraProgreso.setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        barraProgreso = new javax.swing.JProgressBar();
        jButton2 = new javax.swing.JButton();
        txtPath = new javax.swing.JTextField();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Contador de palabras");

        jLabel2.setText("Selecciona el archivo");

        jButton1.setText("Seleccionar");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("Iniciar");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        txtPath.setEditable(false);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 19, Short.MAX_VALUE)
                        .addComponent(txtPath, javax.swing.GroupLayout.PREFERRED_SIZE, 285, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(18, 18, 18)
                                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jButton2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(barraProgreso, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(txtPath, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton2)
                .addGap(9, 9, 9)
                .addComponent(barraProgreso, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 245, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        barraProgreso.setValue(0);
        JFileChooser jfilechooser = new JFileChooser();
        jfilechooser.setDialogTitle("Seleccionar un archivo de texto");
        jfilechooser.setDialogType(JFileChooser.FILES_ONLY);
        if (jfilechooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
            String namefile = jfilechooser.getSelectedFile().toString();
            txtPath.setText(namefile);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    public volatile String text = "";
    public volatile HashMap<String, Integer> wordCount = new HashMap<String, Integer>();
    public volatile int progressBar = 0;
    
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        ProgressBar progressBar1 = new ProgressBar();
        progressBar1.start();
        
        wordCount.clear();
        jTextArea1.setText("");
        barraProgreso.setVisible(true);
        long lines = lineCount();
        long limit = lines/8;
        int core0 = 0;
        int core1 = 1;
        int core2 = 2;
        int core3 = 3;
        int core4 = 4;
        int core5 = 5;
        int core6 = 6;
        int core7 = 7;
        
        FileRead fileRead0 = new FileRead(limit, core0);
        FileRead fileRead1 = new FileRead(limit, core1);
        FileRead fileRead2 = new FileRead(limit, core2);
        FileRead fileRead3 = new FileRead(limit, core3);
        FileRead fileRead4 = new FileRead(limit, core4);
        FileRead fileRead5 = new FileRead(limit, core5);
        FileRead fileRead6 = new FileRead(limit, core6);
        FileRead fileRead7 = new FileRead(limit, core7);
        
        Thread t0 = new Thread(fileRead0);
        Thread t1 = new Thread(fileRead1);
        Thread t2 = new Thread(fileRead2);
        Thread t3 = new Thread(fileRead3);
        Thread t4 = new Thread(fileRead4);
        Thread t5 = new Thread(fileRead5);
        Thread t6 = new Thread(fileRead6);
        Thread t7 = new Thread(fileRead7);
        
        t0.start();
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
        t6.start();
        t7.start();
        
        try {
            t0.join();
            t1.join();
            t2.join();
            t3.join();
            t4.join();
            t5.join();
            t6.join();
            t7.join();
            
        } catch (InterruptedException ex) {
            Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        filter(wordCount);
        
        List<Map.Entry<String, Integer>> top25 = wordCount.entrySet()
                .stream()
                .sorted(reverseOrder(Map.Entry.comparingByValue()))
                .collect(Collectors.toList());
        
        printHistogram(top25);
    }//GEN-LAST:event_jButton2ActionPerformed
    
    public void filter (HashMap<String, Integer> wordCount) {
        String[] discards = {"A", "ANTE", "BAJO", "CABE", "CON", "CONTRA", "DE", "DESDE", "EN", "ENTRE", "HACIA", "HASTA", "PARA", "POR", "SEGÃšN", "SIN", "SO", "SOBRE", "TRAS", "EL", "LA", "LOS", "LAS", "UN", "UNA", "UNOS", "UNAS", "-"};
        for (String discard : discards) {
            if (wordCount.containsKey(discard)) {
                wordCount.remove(discard);
                }
            }
    }
    
    class FileRead implements Runnable {
        private long limit;
        private int core;
        private long lineCount = 0;
        
        public FileRead (long limit, int core) {
            this.limit = limit;
            this.core = core;
        }
        @Override
            public void run() {
                String namefile = txtPath.getText();
            try {
                BufferedReader br = new BufferedReader(new UnicodeReader(new FileInputStream(namefile), "UTF-8"));
                String line;
                while ((line = br.readLine()) != null) {
                    if ((this.limit * this.core) > lineCount) {
                        lineCount ++;
                    }
                    if ((this.limit * this.core) <= lineCount && (this.limit * (this.core + 1)) > lineCount) {
                        StringTokenizer leerArchivo = new StringTokenizer(line);
                        while (leerArchivo.hasMoreTokens()) {
                            String word = leerArchivo.nextToken();
                            if (wordCount.containsKey(word)) {
                                wordCount.put(word, wordCount.get(word) + 1);
                            } else {
                                wordCount.put(word, 1);
                            }
                        }
                        lineCount ++;
                    } if ((this.limit * (this.core + 1)) == lineCount) {
                        break;
                        }
                    }
                System.out.println("Hilo terminado: " + this.core);
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
    }
    
    public class UnicodeReader extends Reader {
        private static final int BOM_SIZE = 4;
        private final InputStreamReader reader;

        /**
         * Construct UnicodeReader
         * @param in Input stream.
         * @param defaultEncoding Default encoding to be used if BOM is not found,
         * or <code>null</code> to use system default encoding.
         * @throws IOException If an I/O error occurs.
         */
        public UnicodeReader(InputStream in, String defaultEncoding) throws IOException {
            byte bom[] = new byte[BOM_SIZE];
            String encoding;
            int unread;
            PushbackInputStream pushbackStream = new PushbackInputStream(in, BOM_SIZE);
            int n = pushbackStream.read(bom, 0, bom.length);

            // Read ahead four bytes and check for BOM marks.
            if ((bom[0] == (byte) 0xEF) && (bom[1] == (byte) 0xBB) && (bom[2] == (byte) 0xBF)) {
                encoding = "UTF-8";
                unread = n - 3;
            } else if ((bom[0] == (byte) 0xFE) && (bom[1] == (byte) 0xFF)) {
                encoding = "UTF-16BE";
                unread = n - 2;
            } else if ((bom[0] == (byte) 0xFF) && (bom[1] == (byte) 0xFE)) {
                encoding = "UTF-16LE";
                unread = n - 2;
            } else if ((bom[0] == (byte) 0x00) && (bom[1] == (byte) 0x00) && (bom[2] == (byte) 0xFE) && (bom[3] == (byte) 0xFF)) {
                encoding = "UTF-32BE";
                unread = n - 4;
            } else if ((bom[0] == (byte) 0xFF) && (bom[1] == (byte) 0xFE) && (bom[2] == (byte) 0x00) && (bom[3] == (byte) 0x00)) {
                encoding = "UTF-32LE";
                unread = n - 4;
            } else {
                encoding = defaultEncoding;
                unread = n;
            }

            // Unread bytes if necessary and skip BOM marks.
            if (unread > 0) {
                pushbackStream.unread(bom, (n - unread), unread);
            } else if (unread < -1) {
                pushbackStream.unread(bom, 0, 0);
            }

            // Use given encoding.
            if (encoding == null) {
                reader = new InputStreamReader(pushbackStream);
            } else {
                reader = new InputStreamReader(pushbackStream, encoding);
            }
        }

        public String getEncoding() {
            return reader.getEncoding();
        }

        public int read(char[] cbuf, int off, int len) throws IOException {
            return reader.read(cbuf, off, len);
        }

        public void close() throws IOException {
            reader.close();
        }
}
        
    private void printHistogram(List<Map.Entry<String, Integer>> top) {
        int value;
        for (int range = 0; range < 25; range++) {
           value = top.get(range).getValue();
           jTextArea1.append((range + 1) + ": " + convertToStars(top, value) + " " + top.get(range) + "\n");
           }
    }

    private String convertToStars(List<Map.Entry<String, Integer>> top, int num) {
        int max = top.get(0).getValue();
        int stars = (num * 60) / max;
        StringBuilder builder = new StringBuilder();
        for (int j = 0; j < stars; j++) {
            builder.append('*');
        }
        return builder.toString();
    }
    
    public long lineCount() {
        long lineCount = 0;
        String namefile = txtPath.getText();
        try (Stream<String> stream = Files.lines(Paths.get(namefile), StandardCharsets.UTF_8)) {
            lineCount = stream.count();
            System.out.println("LÃ­neas: " + lineCount);
        } catch (IOException e) {
            System.out.println(e.toString());
        }
        return lineCount;
    }
    
    public class ProgressBar extends Thread {
        @Override
        public void run() {
            barraProgreso.setVisible(true);
            barraProgreso.setValue(0);
            progressBar = 0;
            while (progressBar <100) {
                progressBar ++;
                barraProgreso.setValue(progressBar);
            }
        }
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Window().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JProgressBar barraProgreso;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField txtPath;
    // End of variables declaration//GEN-END:variables
}
